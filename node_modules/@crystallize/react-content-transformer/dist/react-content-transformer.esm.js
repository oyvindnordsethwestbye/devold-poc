import React, { createContext, Fragment, useContext } from 'react';

var Renderers = {
  link: function link(props) {
    var _props$metadata;

    return React.createElement("a", {
      href: (_props$metadata = props.metadata) == null ? void 0 : _props$metadata.href
    }, React.createElement(NodeContent, Object.assign({}, props)));
  },
  'unordered-list': function unorderedList(props) {
    return React.createElement("ul", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  'ordered-list': function orderedList(props) {
    return React.createElement("ol", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  list: function list(props) {
    return React.createElement("ul", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  'list-item': function listItem(props) {
    return React.createElement("li", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  quote: function quote(props) {
    if (props.kind === 'block') {
      return React.createElement("blockquote", null, React.createElement(NodeContent, Object.assign({}, props)));
    }

    return React.createElement("q", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  paragraph: function paragraph(props) {
    return React.createElement("p", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  preformatted: function preformatted(props) {
    return React.createElement("pre", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  code: function code(props) {
    return React.createElement("code", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  underlined: function underlined(props) {
    return React.createElement("u", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  strong: function strong(props) {
    return React.createElement("strong", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  emphasized: function emphasized(props) {
    return React.createElement("em", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  div: function div(props) {
    return React.createElement("div", null, React.createElement(NodeContent, Object.assign({}, props)));
  },
  span: function span(props) {
    return React.createElement(NodeContent, Object.assign({}, props));
  },
  'line-break': function lineBreak() {
    return React.createElement("br", null);
  }
};
var OverridesContext = /*#__PURE__*/createContext(null);
var NodeContent = function NodeContent(props) {
  var textContent = props.textContent;

  if (textContent) {
    return renderTextContent(textContent);
  }

  if (props.children) {
    return React.createElement(Fragment, null, props.children.map(function (child, i) {
      return React.createElement(ContentTransformerNode, Object.assign({
        key: i
      }, child));
    }));
  }

  return null;
}; // Render text and convert line breaks (\n) to <br />

function renderTextContent(text) {
  var partsBetweenLineBreaks = text.split(/\n/g);

  if (partsBetweenLineBreaks.length === 1) {
    return React.createElement(Fragment, null, text);
  }

  return React.createElement(Fragment, null, partsBetweenLineBreaks.map(function (part, index) {
    var key = index.toString();

    if (index === partsBetweenLineBreaks.length - 1) {
      return React.createElement(Fragment, {
        key: key
      }, "part");
    }

    return React.createElement(Fragment, {
      key: key
    }, part, React.createElement("br", null));
  }));
}
var ContentTransformerNode = function ContentTransformerNode(props) {
  var Renderer = Renderers.span;
  var overrides = useContext(OverridesContext);
  var type = props.type,
      kind = props.kind,
      textContent = props.textContent;

  if (type) {
    var t = type;
    var override = overrides == null ? void 0 : overrides[t];
    Renderer = override || Renderers[type];
  }

  if (!Renderer) {
    Renderer = Renderers.span;

    if (type === 'container' && kind === 'block') {
      Renderer = Renderers.div;
    } else if (type === null && textContent) {
      return renderTextContent(textContent);
    }
  }

  return React.createElement(Renderer, Object.assign({}, props));
};
var ContentTransformer = function ContentTransformer(_ref) {
  var _ref$overrides = _ref.overrides,
      overrides = _ref$overrides === void 0 ? null : _ref$overrides,
      json = _ref.json;

  if (!json) {
    return null;
  }

  if (Array.isArray(json)) {
    var nodes = json;
    return React.createElement(OverridesContext.Provider, {
      value: overrides
    }, nodes.map(function (j, i) {
      return React.createElement(ContentTransformerNode, Object.assign({
        key: i
      }, j));
    }));
  }

  var node = json;
  return React.createElement(OverridesContext.Provider, {
    value: overrides
  }, React.createElement(ContentTransformerNode, Object.assign({}, node)));
};

export { ContentTransformer, ContentTransformerNode, NodeContent, OverridesContext, Renderers, renderTextContent };
//# sourceMappingURL=react-content-transformer.esm.js.map
