{"version":3,"file":"react-image.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { FC, HTMLAttributes, FunctionComponent } from 'react';\n\nexport interface CrystallizeImageVariant {\n  url: string;\n  width: number;\n  height?: number;\n  size?: number;\n}\n\ninterface RichTextContent {\n  html?: Array<string>;\n  json?: Array<any>;\n  plainText?: Array<string>;\n}\n\nexport interface Props extends HTMLAttributes<HTMLImageElement> {\n  children?: FunctionComponent<any>;\n  src?: string;\n  url?: string;\n  sizes?: string;\n  altText?: string;\n  alt?: string;\n  media?: string;\n  // The `html` content has higher priority than `plainText` because it has richer content.\n  // In case of getting both, the `html` is the one that will be displayed.\n  caption?: RichTextContent;\n  variants?: CrystallizeImageVariant[];\n  loading?: 'eager' | 'lazy';\n  _availableSizes?: number[];\n  _availableFormats?: string[];\n}\n\nfunction getVariantSrc(variant: CrystallizeImageVariant): string {\n  return `${variant.url} ${variant.width}w`;\n}\n\nexport const Image: FC<Props> = ({ children, ...restOfAllProps }) => {\n  const {\n    src,\n    url,\n    sizes,\n    variants,\n    altText,\n    alt: altPassed,\n    caption,\n    className,\n    media,\n    _availableSizes,\n    _availableFormats,\n    ...rest\n  } = restOfAllProps;\n\n  let vars = (variants || []).filter((v) => !!v);\n  const alt = typeof altPassed === 'string' ? altPassed : altText;\n\n  // Naive rendering POC\n  if (url && _availableSizes && _availableFormats) {\n    vars = [];\n    const urlWithoutFileExtension = url.replace(/\\.[^/]+$/, '');\n    const match = urlWithoutFileExtension.match(/(.+)(\\/)([^/]+)$/);\n    if (match) {\n      const [, base, , filename] = match;\n\n      _availableSizes.forEach((size) => {\n        _availableFormats.forEach((format) => {\n          vars.push({\n            url: `${base}/@${size}/${filename}.${format}`,\n            width: size,\n          });\n        });\n      });\n    }\n  }\n\n  const hasVariants = vars.length > 0;\n\n  // Get the biggest image from the variants\n  let biggestImage: CrystallizeImageVariant = vars[0];\n  if (hasVariants) {\n    biggestImage = vars.reduce(function (\n      acc: CrystallizeImageVariant,\n      v: CrystallizeImageVariant\n    ): CrystallizeImageVariant {\n      if (!acc.width || v.width > acc.width) {\n        return v;\n      }\n      return acc;\n    },\n    vars[0]);\n  }\n\n  // Determine srcSet\n  const std = vars.filter(\n    (v) => v.url && !v.url.endsWith('.webp') && !v.url.endsWith('.avif')\n  );\n  const webp = vars.filter((v) => v.url && v.url.endsWith('.webp'));\n  const avif = vars.filter((v) => v.url && v.url.endsWith('.avif'));\n  const srcSet = std.map(getVariantSrc).join(', ');\n  const srcSetWebp = webp.map(getVariantSrc).join(', ');\n  const srcSetAvif = avif.map(getVariantSrc).join(', ');\n\n  // Determine the original file extension\n  let originalFileExtension = 'jpeg';\n  if (std.length > 0) {\n    const match = std[0].url.match(/\\.(?<name>[^.]+)$/);\n    originalFileExtension = match?.groups?.name || 'jpeg';\n\n    // Provide correct mime type for jpg\n    if (originalFileExtension === 'jpg') {\n      originalFileExtension = 'jpeg';\n    }\n  }\n\n  const commonProps = {\n    // Ensure fallback src for older browsers\n    src: src || url || (hasVariants ? std[0].url : undefined),\n    alt,\n    caption,\n    width: biggestImage?.width,\n    height: biggestImage?.height,\n  };\n\n  let useWebP = srcSetWebp.length > 0;\n  let useAvif = srcSetAvif.length > 0;\n\n  /**\n   * Only output Avif format if it is smaller than\n   * webP. For the future: show only one of them when\n   * the browser support for Avif is good enough\n   */\n  if (useWebP && useAvif) {\n    const [firstWebp] = webp;\n    const [firstAvif] = avif;\n    if (firstWebp.size && firstAvif.size) {\n      useAvif = firstWebp.size > firstAvif.size;\n    }\n  }\n\n  if (children) {\n    return children({\n      srcSet,\n      srcSetWebp,\n      srcSetAvif,\n      useAvif,\n      useWebP,\n      className,\n      sizes,\n      media,\n      ...commonProps,\n      ...rest,\n      originalFileExtension,\n    });\n  }\n\n  const captionString = caption?.html?.[0] || caption?.plainText?.[0] || '';\n\n  return (\n    <figure className={className}>\n      <picture>\n        {useAvif && (\n          <source\n            srcSet={srcSetAvif}\n            type=\"image/avif\"\n            sizes={sizes}\n            media={media}\n          />\n        )}\n        {useWebP && (\n          <source\n            srcSet={srcSetWebp}\n            type=\"image/webp\"\n            sizes={sizes}\n            media={media}\n          />\n        )}\n        {srcSet.length > 0 && (\n          <source\n            srcSet={srcSet}\n            type={`image/${originalFileExtension}`}\n            sizes={sizes}\n            media={media}\n          />\n        )}\n        {/* eslint-disable-next-line jsx-a11y/alt-text */}\n        <img {...commonProps} {...rest} />\n      </picture>\n      {captionString && (\n        <figcaption dangerouslySetInnerHTML={{ __html: captionString }} />\n      )}\n    </figure>\n  );\n};\n"],"names":["getVariantSrc","variant","url","width","children","restOfAllProps","src","sizes","variants","altText","altPassed","alt","caption","className","media","_availableSizes","_availableFormats","rest","vars","filter","v","match","replace","base","filename","forEach","size","format","push","hasVariants","length","biggestImage","reduce","acc","std","endsWith","webp","avif","srcSet","map","join","srcSetWebp","srcSetAvif","originalFileExtension","groups","name","commonProps","undefined","_biggestImage","height","_biggestImage2","useWebP","useAvif","firstWebp","firstAvif","captionString","html","plainText","_caption$plainText","React","type","dangerouslySetInnerHTML","__html"],"mappings":"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"}