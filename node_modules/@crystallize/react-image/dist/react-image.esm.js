import React from 'react';

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, undefined, groups);
  };

  var _super = RegExp.prototype;

  var _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    _groups.set(_this, groups || _groups.get(re));

    return _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  _inherits(BabelRegExp, RegExp);

  BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    if (result) result.groups = buildGroups(result, this);
    return result;
  };

  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if (typeof substitution === "string") {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    } else if (typeof substitution === "function") {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;

        if (typeof args[args.length - 1] !== "object") {
          args = [].slice.call(args);
          args.push(buildGroups(args, _this));
        }

        return substitution.apply(this, args);
      });
    } else {
      return _super[Symbol.replace].call(this, str, substitution);
    }
  };

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      groups[name] = result[g[name]];
      return groups;
    }, Object.create(null));
  }

  return _wrapRegExp.apply(this, arguments);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["children"],
    _excluded2 = ["src", "url", "sizes", "variants", "altText", "alt", "caption", "className", "media", "_availableSizes", "_availableFormats"];

function getVariantSrc(variant) {
  return variant.url + " " + variant.width + "w";
}

var Image = function Image(_ref) {
  var _biggestImage, _biggestImage2, _caption$html, _caption$plainText;

  var children = _ref.children,
      restOfAllProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  var src = restOfAllProps.src,
      url = restOfAllProps.url,
      sizes = restOfAllProps.sizes,
      variants = restOfAllProps.variants,
      altText = restOfAllProps.altText,
      altPassed = restOfAllProps.alt,
      caption = restOfAllProps.caption,
      className = restOfAllProps.className,
      media = restOfAllProps.media,
      _availableSizes = restOfAllProps._availableSizes,
      _availableFormats = restOfAllProps._availableFormats,
      rest = _objectWithoutPropertiesLoose(restOfAllProps, _excluded2);

  var vars = (variants || []).filter(function (v) {
    return !!v;
  });
  var alt = typeof altPassed === 'string' ? altPassed : altText; // Naive rendering POC

  if (url && _availableSizes && _availableFormats) {
    vars = [];
    var urlWithoutFileExtension = url.replace(/\.[^/]+$/, '');
    var match = urlWithoutFileExtension.match(/(.+)(\/)([^/]+)$/);

    if (match) {
      var base = match[1],
          filename = match[3];

      _availableSizes.forEach(function (size) {
        _availableFormats.forEach(function (format) {
          vars.push({
            url: base + "/@" + size + "/" + filename + "." + format,
            width: size
          });
        });
      });
    }
  }

  var hasVariants = vars.length > 0; // Get the biggest image from the variants

  var biggestImage = vars[0];

  if (hasVariants) {
    biggestImage = vars.reduce(function (acc, v) {
      if (!acc.width || v.width > acc.width) {
        return v;
      }

      return acc;
    }, vars[0]);
  } // Determine srcSet


  var std = vars.filter(function (v) {
    return v.url && !v.url.endsWith('.webp') && !v.url.endsWith('.avif');
  });
  var webp = vars.filter(function (v) {
    return v.url && v.url.endsWith('.webp');
  });
  var avif = vars.filter(function (v) {
    return v.url && v.url.endsWith('.avif');
  });
  var srcSet = std.map(getVariantSrc).join(', ');
  var srcSetWebp = webp.map(getVariantSrc).join(', ');
  var srcSetAvif = avif.map(getVariantSrc).join(', '); // Determine the original file extension

  var originalFileExtension = 'jpeg';

  if (std.length > 0) {
    var _match$groups;

    var _match = std[0].url.match( /*#__PURE__*/_wrapRegExp(/\.((?:(?!\.)[\s\S])+)$/, {
      name: 1
    }));

    originalFileExtension = (_match == null ? void 0 : (_match$groups = _match.groups) == null ? void 0 : _match$groups.name) || 'jpeg'; // Provide correct mime type for jpg

    if (originalFileExtension === 'jpg') {
      originalFileExtension = 'jpeg';
    }
  }

  var commonProps = {
    // Ensure fallback src for older browsers
    src: src || url || (hasVariants ? std[0].url : undefined),
    alt: alt,
    caption: caption,
    width: (_biggestImage = biggestImage) == null ? void 0 : _biggestImage.width,
    height: (_biggestImage2 = biggestImage) == null ? void 0 : _biggestImage2.height
  };
  var useWebP = srcSetWebp.length > 0;
  var useAvif = srcSetAvif.length > 0;
  /**
   * Only output Avif format if it is smaller than
   * webP. For the future: show only one of them when
   * the browser support for Avif is good enough
   */

  if (useWebP && useAvif) {
    var firstWebp = webp[0];
    var firstAvif = avif[0];

    if (firstWebp.size && firstAvif.size) {
      useAvif = firstWebp.size > firstAvif.size;
    }
  }

  if (children) {
    return children(_extends({
      srcSet: srcSet,
      srcSetWebp: srcSetWebp,
      srcSetAvif: srcSetAvif,
      useAvif: useAvif,
      useWebP: useWebP,
      className: className,
      sizes: sizes,
      media: media
    }, commonProps, rest, {
      originalFileExtension: originalFileExtension
    }));
  }

  var captionString = (caption == null ? void 0 : (_caption$html = caption.html) == null ? void 0 : _caption$html[0]) || (caption == null ? void 0 : (_caption$plainText = caption.plainText) == null ? void 0 : _caption$plainText[0]) || '';
  return React.createElement("figure", {
    className: className
  }, React.createElement("picture", null, useAvif && React.createElement("source", {
    srcSet: srcSetAvif,
    type: "image/avif",
    sizes: sizes,
    media: media
  }), useWebP && React.createElement("source", {
    srcSet: srcSetWebp,
    type: "image/webp",
    sizes: sizes,
    media: media
  }), srcSet.length > 0 && React.createElement("source", {
    srcSet: srcSet,
    type: "image/" + originalFileExtension,
    sizes: sizes,
    media: media
  }), React.createElement("img", Object.assign({}, commonProps, rest))), captionString && React.createElement("figcaption", {
    dangerouslySetInnerHTML: {
      __html: captionString
    }
  }));
};

export { Image };
//# sourceMappingURL=react-image.esm.js.map
